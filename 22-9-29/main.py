from tqdm import tqdm
# import tqdm for display the progress bar . Function tqdm() won't change its parameters' properties.

class sgenerator:
    def __init__(self):
        '''
        Initialize the sentence generator class . Data was read from rslt.txt(Probability) and py_hz.txt (Pinyin and Han
        Characters) .
        '''
        ret = {}
        filestream = open('py_hz.txt', 'r', encoding='GBK')
        print('GENERATING PINYIN ANALYZER : ', end=' ')
        for line in tqdm(filestream):
            arr = line.strip('\n').split(' ')
            ret[arr[0]] = arr[1:]
        filestream.close()
        print(' ')
        self.pinyin_dic = ret

        # Below : initialize the probability dict(self.P_dict) .
        self.P_dic = {}
        # Mark string : The combination between a Han char and a mark shouldn't be considered by the program . If
        #               there do have such a combination , skip it .
        mark_str = '\n\t\r `1234567890-=~!@#$%^&*()_+,./;\'[]\\<>?:\"{}|～！…￥（）——`～{}|·「」、；‘’“”，。/《》？'
        # Reading probability data from pstream file .
        Pstream = open('rslt.txt', 'r', encoding='GBK')
        print('GENERATING PROBABILITY : ', end=' ')
        for line in tqdm(Pstream):
            line = line.split(' ')

            if line[0] not in mark_str and line[1] not in mark_str:
                self.P_dic[str(line[0]) + str(line[1])] = line[2]
        print(' ')
        Pstream.close()
        # Some properties . self.inputs is the input string of pinyins . self.matrix is the probability matrix generated
        # according to the inputs . self.routes is all the sentence route generated by self.matrix .
        self.inputs = ''
        self.matrix = []
        self.routes = []

    def __str__(self):
        for item in self.pinyin_dic:
            return str(item) + ' : ' + str(self.pinyin_dic[item])

    def set_input(self, inputs: str):
        self.inputs = inputs.split(' ')

    def get_pure_char(self, data: list):
        """
        As the array read from pinyin_hz.txt is a 2-dimension array , this function is to get the character
        array without other data , so that self.gen_column can deal with them .
        :param data: a dimension from self.matrix
        :return: pure character array without probability and pointer .
        """
        ret = []
        for item in data:
            ret.append(item[0])
        return ret

    def gen_column(self, list1, list2):
        """
        Generate a full column . set list1 = 0 or None to generate the first column .
        According to Xun , to execute the Viterbi Algorithm , we need a 3-dimension array . This function takes 2
        parameters: list1 is the list of w1 (previous char list) , list2 is the list of w2 , and the function can
        generate a list of all the list2 chars' max P(w2|w1) and the pointer of w1 .
        :param list1: previous char list
        :param list2: next char list
        :return:
        """
        ret = []
        if list1 != 0 and list1 is not None:
            # Not the first line . P and pointer are related to the previous line . the follow codes will compute
            # them and generate a single traid , and append it to the return list 'ret'
            pc1 = self.get_pure_char(list1)
            for item in list2:
                tlist = [item]
                max_key = 0
                max_val = 0
                for i in range(len(pc1)):
                    key = str(pc1[i])+str(item)
                    # if key == "是你":
                    #     print(self.P_dic[key])
                    if key in self.P_dic:
                        if float(self.P_dic[key]) > float(max_val):
                            max_key = i
                            max_val = self.P_dic[key]
                tlist.append(float(max_val))
                tlist.append(int(max_key))
                ret.append(tlist)
        else:
            # in the first line , all the P is 1 and all the pointer is 0
            for item in list2:
                tlist = [item]
                tlist.append(1)
                tlist.append(0)
                ret.append(tlist)
        return ret

    def gen_matrix(self):
        old = []
        for item in self.inputs:
            old.append(self.pinyin_dic[item])
        # Now : Giving an initial value to the first char list .
        self.matrix.append(self.gen_column(0, old[0]))
        for i in range(len(old)-1):
            self.matrix.append(self.gen_column(old[i], old[i+1]))

        for line in self.matrix:
            print(line)

    def gen_route(self, i, last, route: list):
        ret = route
        if i == len(self.matrix):
            self.routes.append(ret[:])
            '''
            [ ! ] VERY IMPORTANT NOTATION ! @ Lu
            '''
            print('----------Route Generated : '+str(ret))
            return ret
        for j in range(len(self.matrix[i])):
            if self.matrix[i][j][2] == last:
                print('--'*i + 'Generating: ' + str(ret) + ' + ' + str(j) )
                ret.append(j)
                # print('-'*i + str(self.matrix[i][j][0]))
                self.gen_route(i+1, j, ret)
                ret.pop()

    def gen_sentence(self):
        print(self.routes)
        ret = []
        for line in self.routes:
            current_s = ''
            current_p = 1
            for i in range(len(self.matrix)):
                triple = self.matrix[i][line[i]]
                current_s += triple[0]
                current_p *= triple[1]
            ret.append([current_s, current_p])
        print(ret)
        max_p = 0
        tmp = []
        for item in ret:
            if float(item[1]) >= max_p:
                tmp = item
                max_p = float(item[1])
        print(tmp)
        return tmp


if __name__ == "__main__":
    sgen = sgenerator()
    sgen.set_input('wo hao shuai')
    sgen.gen_matrix()
    sgen.gen_route(0, 0, [])
    sgen.gen_sentence()

